use std::str::FromStr;

use parser::util;
use parser::types::Expr;
use parser::types::Pattern;
use parser::types::ConstExpr;

grammar;


// Defines the precedence for non-terminal symbols
match {
    r"(true|false)" => BOOL,
    r"[+\-]?(0|[1-9][0-9]*)" => INT,
    r"[+\-]?(inf|NaN|((0|[1-9][0-9]*)\.[0-9]*|\.[0-9]+)([eE][+\-]?[0-9]+)?|(0|[1-9][0-9]*)[eE][+\-]?[0-9]+)"
        => REAL,
    r"'([^\\'[[:cntrl:]]]|\\([\\'0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))'"
        => CHAR,
    r#""([^\\"[[:cntrl:]]]|\\([\\"0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))*""#
        => STRING
} else {
    "as",
    "end",
    "fun",
    "in",
    "let",
    "match",
    "rec",
    "with",
} else {
    r"[a-z_][a-zA-Z0-9_]*" => ID,
    _
}


/// ========================
/// # Constant Expressions
/// ========================


pub Bool: bool = {
    BOOL => bool::from_str(<>).unwrap()
};


pub Int: i64 = {
    INT => i64::from_str(<>).unwrap()
};


pub Real: f64 = {
    REAL => f64::from_str(<>).unwrap()
};


pub Char: char = {
    CHAR => {
        let chr = <>;
        let mut chars = chr[1..chr.len() - 1].chars();

        util::unescape(&mut chars).unwrap()
    }
};


pub String: String = {
    STRING => {
        let s = <>;
        let len = s.len();
        let mut chars = s[1..len - 1].chars();
        let mut string = String::with_capacity(len);

        while let Some(c) = util::unescape(&mut chars) {
            string.push(c);
        }

        string
    }
};


pub ConstExpr: ConstExpr = {
    Bool => ConstExpr::Bool(<>),
    Int => ConstExpr::Int(<>),
    Real => ConstExpr::Real(<>),
    Char => ConstExpr::Char(<>),
    String => ConstExpr::String(<>),
};


/// ============
/// # Patterns
/// ============


pub Pattern: Pattern = {
    <pat: TaggedPattern> "as" <name: ID> => Pattern::Named {
        pat: Box::new(pat),
        name: name.to_string()
    },

    TaggedPattern
};


TaggedPattern: Pattern = {
    "Con" <pat: BasePattern> => Pattern::Tagged {
        pat: Box::new(pat)
    },

    BasePattern
};


FieldPattern: (String, Pattern) = {
    <label: ID> "=" <pat: Pattern> ";" => {
        (label.to_string(), pat)
    },
};


BasePattern: Pattern = {
    "_" => Pattern::Any,

    "Con" => Pattern::Con,

    <ConstExpr> => Pattern::Const {
        constant: <>
    },

    <id: ID> => Pattern::Ident {
        id: id.to_string()
    },

    "{" <fields: FieldPattern+> "}" => Pattern::Record {
        fields: fields
    },
};


/// ===============
/// # Expressions
/// ===============


FieldDecl: (String, Expr) = {
    <label: ID> "=" <expr: Expr> ";" => {
        (label.to_string(), expr)
    },
};


MatchRule: (Pattern, Expr) = {
    <pat: Pattern> "->" <expr: Expr> => {
        (pat, expr)
    }
};


MatchRules: Vec<(Pattern, Expr)> = {
    <init: MatchRule> <v: ("|" <MatchRule>)*> => {
        let mut v = v;
        v.insert(0, init);
        v
    }
};


pub Expr: Expr = {
    ID => Expr::Var {
        var: <>.to_string()
    },

    ConstExpr => Expr::Const {
        constant: <>
    },

    "Con" <expr: Expr> => Expr::New {
        expr: Box::new(expr)
    },

    "(" <expr: Expr> ")" => Expr::Parens {
        expr: Box::new(expr)
    },

    "{" <fields: FieldDecl+> "}" => Expr::NewRecord {
        fields: fields
    },

    "match" <expr: Expr> "with" <rules: MatchRules> "end" => Expr::Match {
        expr: Box::new(expr),
        rules: rules
    },

    "fun" <pat: Pattern> "->" <expr: Expr> => Expr::Abstraction {
        pat: pat,
        expr: Box::new(expr)
    },

    <func: Expr> <arg: Expr> => Expr::Application {
        func: Box::new(func),
        arg: Box::new(arg)
    },

    <expr: Expr> "." <name: ID> => Expr::GetField {
        expr: Box::new(expr),
        name: name.to_string()
    },

    <expr: Expr> "." <name: ID> "<-" <value: Expr> => Expr::SetField {
        expr: Box::new(expr),
        name: name.to_string(),
        value: Box::new(value)
    },

    "let" <pat: Pattern> "=" <value: Expr> "in" <expr: Expr> => Expr::Let {
        pat: pat,
        value: Box::new(value),
        expr: Box::new(expr)
    },

    "let" "rec" <var: ID> "=" "fun" <pat: Pattern> "->" <value: Expr> "in"
    <expr: Expr> => Expr::Recursion {
        var: var.to_string(),
        pat: pat,
        value: Box::new(value),
        expr: Box::new(expr)
    }
};
