use std::str::FromStr;

use parser::util;
use parser::types::Expr;
use parser::types::Pattern;
use parser::types::ConstExpr;

grammar;


// Defines the precedence for non-terminal symbols
match {
    r"(true|false)" => BOOL,
    r"[+\-]?(0|[1-9][0-9]*)" => INT,
    r"[+\-]?(inf|NaN|((0|[1-9][0-9]*)\.[0-9]*|\.[0-9]+)([eE][+\-]?[0-9]+)?|(0|[1-9][0-9]*)[eE][+\-]?[0-9]+)"
        => REAL,
    r"'([^\\'[[:cntrl:]]]|\\([\\'0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))'"
        => CHAR,
    r#""([^\\"[[:cntrl:]]]|\\([\\"0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))*""#
        => STRING
} else {
    r"[a-z_][a-zA-Z0-9_]*" => ID,
    _
}


/// ========================
/// # Constant Expressions
/// ========================


pub Bool: bool =
    BOOL => {
        bool::from_str(<>).unwrap()
    };


pub Int: i64 =
    INT => {
        i64::from_str(<>).unwrap()
    };


pub Real: f64 =
    REAL => {
        f64::from_str(<>).unwrap()
    };


pub Char: char =
    CHAR => {
        let chr = <>;
        let mut chars = chr[1..chr.len() - 1].chars();

        util::unescape(&mut chars).unwrap()
    };


pub String: String =
    STRING => {
        let s = <>;
        let len = s.len();
        let mut chars = s[1..len - 1].chars();
        let mut string = String::with_capacity(len);

        while let Some(c) = util::unescape(&mut chars) {
            string.push(c);
        }

        string
    };


pub ConstExpr: ConstExpr = {
    Bool => ConstExpr::Bool(<>),
    Int => ConstExpr::Int(<>),
    Real => ConstExpr::Real(<>),
    Char => ConstExpr::Char(<>),
    String => ConstExpr::String(<>),
};


/// ============
/// # Patterns
/// ============


FieldPattern: Vec<(String, Pattern)> = {
    <label: ID> "=" <pat: Pattern> ";" => {
        vec![(label.to_string(), pat)]
    },

    <label: ID> "=" <pat: Pattern> ";" <rest: FieldPattern> => {
        let mut fields = Vec::with_capacity(rest.len() + 1);
        fields.push((label.to_string(), pat));
        fields.extend(rest.iter().cloned());
        fields
    },
};


Pattern: Pattern = {
    "_" => Pattern::Any,

    "Con" => Pattern::Con,

    <id: ID> => Pattern::Ident {
        id: id.to_string()
    },

    "Con" <pat: Pattern> => Pattern::Tagged {
        pat: Box::new(pat)
    },

    "{" <fields: FieldPattern> "}" => Pattern::Record {
        fields: fields
    },

    <pat: Pattern> "as" <name: ID> => Pattern::Named {
        pat: Box::new(pat),
        name: name.to_string()
    },
};



/// ===============
/// # Expressions
/// ===============


FieldDecl: Vec<(String, Expr)> = {
    <label: ID> "=" <expr: Expr> ";" => {
        vec![(label.to_string(), expr)]
    },

    <label: ID> "=" <expr: Expr> ";" <rest: FieldDecl> => {
        let mut fields = Vec::with_capacity(rest.len() + 1);
        fields.push((label.to_string(), expr));
        fields.extend(rest.iter().cloned());
        fields
    },
};



MatchRule: Vec<(Pattern, Expr)> = {
    <pat: Pattern> "->" <expr: Expr> => {
        vec![(pat, expr)]
    },

    <pat: Pattern> "->" <expr: Expr> "|" <rest: MatchRule> => {
        let mut rules = Vec::with_capacity(rest.len() + 1);
        rules.push((pat, expr));
        rules.extend(rest.iter().cloned());
        rules
    }
};


Expr: Expr = {
    ID => Expr::Var {
        var: <>.to_string()
    },

    ConstExpr => Expr::Const {
        expr: <>
    },

    "Con" <expr: Expr> => Expr::New {
        expr: Box::new(expr)
    },

    "(" <expr: Expr> ")" => Expr::Parens {
        expr: Box::new(expr)
    },

    "{" <fields: FieldDecl> "}" => Expr::NewRecord {
        fields: fields
    },

    "match" <expr: Expr> "with" <rules: MatchRule> "end" => Expr::Match {
        expr: Box::new(expr),
        rules: rules
    },

    "fun" <pat: Pattern> "->" <expr: Expr> => Expr::Abstraction {
        pat: pat,
        expr: Box::new(expr)
    },

    <func: Expr> <arg: Expr> => Expr::Application {
        func: Box::new(func),
        arg: Box::new(arg)
    },

    <expr: Expr> "." <name: ID> => Expr::GetField {
        expr: Box::new(expr),
        name: name.to_string()
    },

    <expr: Expr> "." <name: ID> "<-" <value: Expr> => Expr::SetField {
        expr: Box::new(expr),
        name: name.to_string(),
        value: Box::new(value)
    },

    "let" <pat: Pattern> "=" <value: Expr> "in" <expr: Expr> => Expr::Let {
        pat: pat,
        value: Box::new(value),
        expr: Box::new(expr)
    },

    "let" "rec" <var: ID> "=" "fun" <pat: Pattern> "->" <value: Expr> "in"
    <expr: Expr> => Expr::Recursion {
        var: var.to_string(),
        pat: pat,
        value: Box::new(value),
        expr: Box::new(expr)
    }
};
