use std::str::FromStr;

use parser::util;
use parser::types::ConstExpr;
use parser::types::Pattern;

grammar;


// Defines the precedence for non-terminal symbols
match {
    r"(true|false)" => BOOL,
    r"[+\-]?(0|[1-9][0-9]*)" => INT,
    r"[+\-]?(inf|NaN|((0|[1-9][0-9]*)\.[0-9]*|\.[0-9]+)([eE][+\-]?[0-9]+)?)"
        => REAL,
    r"'([^\\'[[:cntrl:]]]|\\([\\'0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))'"
        => CHAR,
    r#""([^\\"[[:cntrl:]]]|\\([\\"0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))*""#
        => STRING
} else {
    r"[a-z_][a-zA-Z0-9_]*" => ID,
    _
}


/// ========================
/// # Constant Expressions
/// ========================


pub Bool: bool =
    BOOL => {
        bool::from_str(<>).unwrap()
    };


pub Int: i64 =
    INT => {
        i64::from_str(<>).unwrap()
    };


pub Real: f64 =
    REAL => {
        f64::from_str(<>).unwrap()
    };


pub Char: char =
    CHAR => {
        let chr = <>;
        let mut chars = chr[1..chr.len() - 1].chars();

        util::unescape(&mut chars).unwrap()
    };


pub String: String =
    STRING => {
        let s = <>;
        let len = s.len();
        let mut chars = s[1..len - 1].chars();
        let mut string = String::with_capacity(len);

        while let Some(c) = util::unescape(&mut chars) {
            string.push(c);
        }

        string
    };


pub ConstExpr: ConstExpr = {
    Bool => ConstExpr::Bool(<>),
    Int => ConstExpr::Int(<>),
    Real => ConstExpr::Real(<>),
    Char => ConstExpr::Char(<>),
    String => ConstExpr::String(<>),
};


/// ============
/// # Patterns
/// ============


FieldPattern: Vec<(String, Pattern)> = {
    <label: ID> "=" <pat: Pattern> ";" => {
        vec![(label.to_string(), pat)]
    },

    <label: ID> "=" <pat: Pattern> ";" <rest: FieldPattern> => {
        let mut fields = Vec::with_capacity(rest.len() + 1);
        fields.push((label.to_string(), pat));
        fields.extend(rest.iter().cloned());
        fields
    },
};


Pattern: Pattern = {
    "_" => Pattern::Any,

    "Con" => Pattern::Con,

    <id: ID> => Pattern::Ident {
        id: id.to_string()
    },

    "Con" <pat: Pattern> => Pattern::Tagged {
        pat: Box::new(pat)
    },

    "{" <fields: FieldPattern> "}" => Pattern::Record {
        fields: fields
    },

    <pat: Pattern> "as" <name: ID> => Pattern::Named {
        pat: Box::new(pat),
        name: name.to_string()
    },
};
