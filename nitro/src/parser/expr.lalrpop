use std::str::FromStr;

use parser::util;
use parser::types::ConstExpr;

grammar;


// Defines the precedence for non-terminal symbols
match {
    r"(true|false)" => BOOL,
    r"[+\-]?(0|[1-9][0-9]*)" => INT,
    r"[+\-]?(inf|NaN|((0|[1-9][0-9]*)\.[0-9]*|\.[0-9]+)([eE][+\-]?[0-9]+)?)"
        => REAL,
    r"'([^\\'[[:cntrl:]]]|\\([\\'0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))'"
        => CHAR,
    r#""([^\\"[[:cntrl:]]]|\\([\\"0abtnvfr]|u[0-9a-f]{4}|x[0-9a-f]{2}))*""#
        => STRING
} else {
    r"[a-z_][a-zA-Z0-9_]*" => ID,
    _
}


/// ========================
/// # Constant Expressions
/// ========================


pub Bool: bool =
    BOOL => {
        bool::from_str(<>).unwrap()
    };


pub Int: i64 =
    INT => {
        i64::from_str(<>).unwrap()
    };


pub Real: f64 =
    REAL => {
        f64::from_str(<>).unwrap()
    };


pub Char: char =
    CHAR => {
        let chr = <>;
        let mut chars = chr[1..chr.len() - 1].chars();

        util::unescape(&mut chars).unwrap()
    };


pub String: String =
    STRING => {
        let s = <>;
        let len = s.len();
        let mut chars = s[1..len - 1].chars();
        let mut string = String::with_capacity(len);

        while let Some(c) = util::unescape(&mut chars) {
            string.push(c);
        }

        string
    };


pub ConstExpr: ConstExpr = {
    Bool => ConstExpr::Bool(<>),
    Int => ConstExpr::Int(<>),
    Real => ConstExpr::Real(<>),
    Char => ConstExpr::Char(<>),
    String => ConstExpr::String(<>),
};
